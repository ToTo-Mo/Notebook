05 대칭키 암호
===

대칭키 암호는 암호화(encryption)와 복호화(decryption)에 같은 암호 키를 사용하는 것을 의미한다. 대칭키 암호에서는 암호화 하는 측과 복호화 하는 측이 같은 암호 키를 공유해야 한다. 대칭키 암호는 혼돈과 확산의 성질을 이용하여 평문을 암호화 한다. 

혼돈(confusion)효과는 치환(substitution)을 통해 형성되고, 확산(diffusion)효과는 순열(permutation)을 통해 얻는다. 대칭키 암호를 설계 할 떄는 이 치환과 순열 연산을 포함하여 한개의 라운드(round)를 구성한다.

대칭키 암호에서 라운드를 어떻게 구성할지 결정하였다면, 이 라운드를 반복적으로 사용하는 구조로 대칭키 암호를 완성한다. 대칭키 암호 방식은 데이터를 변환하는 방법에 따라서 스트림 암호와 블록 암호로 나뉜다.

대칭키의 암호화 성능은 키의 길이에 의존하는데 일반적인 키의 크기는 40 ~ 448bits이다. 슈퍼컴퓨터를 이용한다면 56bits의 키는 24시간 내에 해독이 가능하나, 128bits키는 2^72배 오래 걸린다. 이는 우주의 역사보다 긴 시간이다.

- 장점

    - 키 크기가 상대적으로 작고 암호 알고리즘 내부 구조가 단순하다.
    - 시스템 개발 환경에 용이하고, 비대칭 키에 비해 암호화와 복호화 속도가 빠르다.

- 단점

    - 당사자간에 동일한 키를 공유해야 하므로 키 관리의 어려움이 있다.
    - 잦은 키 변경이 있는 경우 불편함을 초래한다.
    - 디지털 서명 기법의 적용과 안전성을 분석하기가 어려우며 중재가 필요하다.


# 1. 블록 암호

블록 암호는 암호문을 만들기 위하여 암호 키와 알고리즘이 데이터 블록 단위로 적용되는 암호화 방법이다. 평문의 동일 블록들이 하나의 메시지에서 동일한 암호문으로 되지 않도록 하기 위해 이전 암호 블록의 암호문을 다음 블록에 순서대로 적용하는 것이다.

라운드 함수를 사용해 반복적으로 암호화 가정을 행함으로써 암호화 강도를 향상시킨다. 블록암호는 전치와 치환를 이용한다. 이러한 블록암호 구조에서 Feistel구조와 SPN(Substitution-Permutation Network)구조가 있다.

- 장점

    - 소프트웨어적으로 구현할 수 있다.
    - 전치와 치환을 반복하여 평문과 암호문으로부터 키에 대한 정보를 찾아내기 어렵다.
    - 데이터 전송, 대용량 데이터 저장시 사용한다.

- 단점

    - 느린 암호화 속도와 에러 전파의 문제가 있다.
    - 데이터의 크기가 작을 경우 효율적으로 암호화하기에는 적합하지 않다.

## 1.1 Feistel 구조

DES를 포함한 기존의 거의 모든 블록 암호 알고리즘은 1973년 IBM의 Horst Feistel이 처음 고안한 구조를 따르고 있다. Feistel 구조는 아래의 매개변수 및 설계 기능에 따라 결정된다.

- Block Size 
- Key Size
- Number of rounds
- Subkey Generation Algorithm
- Fast software encryption/decryption

아래의 그림은 Feistel 구조이며, 암호화하려는 정보를 길이가 같은 두개의 정보로 나눈다. 이를 $L_0, \; R_0$라 하고, 라운드 0 ~ n에서 사용되는 키를 $K_i$ 그리고 라운드 함수를 $F()$로 놓는다.

![](image/05%20Feistel%20Cipher%20Diagram.png)

암호화 과정에서는 각 라운드에서 다음과 같은 연산이 이루어진다.

- $L_{i+1} = R_i$
- $R_{i+1} = L_i \bigoplus F(R_i,K_i)$

모든 라운드가 끝난후 최종적으로 $R_(n+1), \; L_(n+1)$이 암호화된 값이 된다.

복호화 과정에서는 반대의 연산이 이루어진다. $R_(n+1), \; L_(n+1)$이 주어졌을 때, 각 복호화 라운드에서는 다음과 같은 연산이 이루어진다.

- $R_i = L_{i+1}$
- $L_i = R_{i+1} \bigoplus F(L_{i+1},K_i)$

최종적으로 원래 값 $L_0, \; R_0$를 얻는다. 

이 모델의 장점 중 하나는 암호화 과정과 복호화 과정이 키 순서를 제외한 전체가 같은 계산을 반복한다는 것이다. 또한 라운드 함수에 역연산이 있을 필요가 없다.

DES, 블로피시, SEED등은 Feistel 구조를 가진 알고리즘이다. 

## 1.2 DES. Data Encrpytion Standard

가장 널리 알려진 대칭키 암호화 알고리즘으로 최초로 미국 표준으로 선정되어 은행 거래시 보안 알고리즘으로 자주 사용되고 있다.

64bis 블록 암호를 사용하며 이중 8bits는 parity check에 사용된다. 키는 54bits를 사용한다.

평문이나 키에 약간의 변화만 생겨도 암호문에 매우 큰 변화를 가져오는 avalanche 효과가 강하다. 최근에는 DES암호화를 세 개의 키로 세 번 반복하여 암호의 강도를 높인 Triple-DES가 사용되고 있다.

### 암호화

1. Initial Permutation(초기 치환) - 
2. 16 Round
3. Inverse Initial Permutation(역초기 치환)

![](image/05%20DES%20구조도도.jpg)

![alt](image/05%20DES%20구조도.png)

### 1. Initial Permutation 

### 2. Single Round

![](image/05%20DES%20Single%20Round.png)

### 복호화

- 암호화 알고리즘을 다시 사용
- 암호화 과정의 반대 순서로 서브키 입력, 즉 16번째 서브키를 첫번째 과정에,

> 키 사이즈별 탐색에 소요되는 시간
> 
    | Key Size(bits) | Number of Alternative Keys | Time required at $10^{6}$ Decryptions/us |
    | -------------- | -------------------------- | -------------------------------------- |
    | 32             | $2^{32} = 4.3 x 10^9$        | 2.15 milliseconds                      |
    | 56             | $2^{56} = 7.2 x 10^{16}$       | 10 hours                               |
    | 128            | $2^{128} = 3.4 x 10^{38}$      | $5.4 * 10^{18}$ years                    |
    | 168            | $2^{168} = 3.7 x 10^{50}$      | $5.9 * 10^{30}$ years                    |

## 1.4 Triple DES

Double DES는 2개의 다른 키로 2번 암호화하여 전송하는 반면 Triple DES는 2개의 키를 사용하여 3번 암호화 한다. Triple DES에 대한 실용적인 공격 방법은 발견되지 않고 있다.

> Double DES에서 키의 길이는 112비트이며 이는 $2^63$정도의 시간 복잡도로 복호화 할 수 있다.


## 1.5 AES. Advanced Encryption Standard

DES의 64비트 키 길이는 공격에 취약하다. 1997년 NIST(국립표준기술원 National Institute of Standards and Technology)에서 DES를 대치하는 128 비트 대칭키 암호 시스템을 마련하기 위한 계획을 발표합니다. AES는 다음 요건을 만족해야 했습니다.

- 요건

    - 3중 DES보다 효율적, 안전성
    - 128비트 이상의 키 길이

15개의 알고리즘이 후보로 채택되었으며, 2008년 8월 Rijndael 알고리즘이 최종적으로 채택되었습니다.

# 2. 블록 암호 운영 방식

다양한 응용 환경하에서 적절한 암호화 도구로 사용될 수 있는 운영 방식을 제시하였다.

- ECB 모드 : Electric CodeBook mode(전자 부호표 모드) 
- CBC 모드 : Cipher Block Chaining mode(암호 블록 연쇄 모드) 
- CFB 모드 : Cipher-FeedBack mode(암호 피드백 모드) 
- OFB 모드 : Output-FeedBack mode(출력 피드백 모드) 
- CTR 모드 : CounTeR mode(카운터 모드) 

## 2.1 ECB(Electric CodeBook mode, 전자 부호표 모드) 모드

ECB 모드에서는 평문 블록을 암호화 한 것이 그대로 암호문 블록이 되다. 즉, 동일한 내용을 갖는 평문 블록은 이에 대응되는 동일한 암호문 블록으로 변환된다.

### 특징

- 가장 간단한 모드
- 가장 기밀성이 낮은 모드
- ECB 모드에서는 평문 블록과 암호문 블록이 일대일 관계를 유지
- 암호문을 살펴보는 것만으로도 평문 속에 패턴의 반복이 있다는 것을 알게되며, 이것을 실마리로 암호 해독을 할 수 있음
- 이 모드는 안전하지 않음

![alt](image/05%20ECB%20암호화.png)
![](image/05%20ECB%20복호화.png)

### 공격

- ECB 모드에서는 모든 평문 블록이 각각 개별적으로 암호화되고, 개별적을 복호화 된다.
- 적극적 공격자인 멜로리가 악의를 가지고 암호문 블록을 서로 바꾸었다면, 수신자가 그 암호문을 복호화 하면 바뀐 암호화 블록에 대응하는 평문 블록도 바뀌게 된다.

## 2.2 CBC(Cipher Block Chaning mode, 암호 블록 연쇄 모드) 모드

CBC 모드에서는 한단계 앞의 암호문 블록에 평문 블록을 XOR하고 나서 암호화를 수행한다. 따라서 생성되는 각각의 암호문 블록은 단지 현재 평문 블록 뿐만 아니라 그 이전의 평문 블록들의 영향도 받게 됩니다.

![](image/05%20CBC%20암호화.png)
![](image/05%20CBC%20복호화.png)

### 초기화 벡터

최초의 평문 블록을 암호화할 때는 한단계 앞의 암호문 블록이 존재하지 않으므로 대신할 비트열인 한개의 블록 IV(initialization vector)를 준비한다. 

IV는 비밀키와 마찬가지로 송신자와 수신자간에 미리 약속되어 있어야 하지만 공개된 값을 사용해도 무방하다. 또한 IV는 암호화 할 때마다 다른 랜덤 비트열을 이용하는 것이 보통이다.

### 패딩

실제 CBC 모드를 적용할 경우에 암호화될 평문의 길이는 가변적이기 때문에 마지막 블록의 길이가 일정하지 않다. 이 경우에는 부족한 길이만큼 '0'이나 임의의 비트들로 채워 넣는다.

![](image/05%20CBC%20모드%20패딩.jpg)

### 특징

- 평문 블록은 반드시 1단계 앞의 암호문 블록과 XOR을 한다. 이는 평문 블록1과 평문 블록2가 동일하다고 해도 암호 블록1과 암호블록2가 동일하지 않다.

- CBC 모드에서는 일부의 평문 블록만을 뽑아내서 암호화할 수 없다. 순차적을 암호화 해야 한다.

- CBC 모드의 암호문 블록이 1개 파손되었다면, 이때 암호문 블록의 길이가 바뀌지 않는다면, 복호화 했을때 평문 블록에 미치는 영향은 2개의 블록에 머문다.

    ![](image/05%20CBC%20암호화%20블록%20손상.png)

- CBC 모드에서 암호문 블록에서 비트 누락이 생기면 그 이후의 평문 블록 전체에 영향을 미친다.

    ![](image/05%20CBC%20암호문%20블록%20누락.png)

### 공격

- 복호화 과정시 IV의 비트 반전으로 평문에 영향을 주는 방법
  
### 활용

- IPsec에는 통신의 기밀성을 지키기 위해 CBC 모드를 사용

    예를 들어, 트리플 DES를 CBC 모드로 사용한 3DES-CBC나, AES를 CBC 모드로 사용한 AES-CBC등이 여기에 해당한다.

- 인증을 수행하는데 대칭암호 시스템의 하나인 Kerberos version5에서도 사용한다.

## 2.3 CFB(Cipher-FeedBack mode암호 피드백 모드) 모드

CFB 모드에서는 한 단계 앞의 암호문 블록을 암호 알고리즘의 입력으로 사용합니다. 피드백은 이전 블록의 암호문을 암호화의 입력으로 사용한다는 의미입니다.

![alt](image/05%20CFB%20암호화.png)

### CBC와 CFB 비교

![alt](image/05%20CBC와%20CFB%20비교.png)

### 복호화

CFB 모드에서 복호화를 수행할 경우, 블록 암호 알고리즘 자체는 암호화를 수행하고 있다는 것에 주의해야 한다.

키 스트림은 암호화에 의해 생성된다.

### 공격

CFB 모드에 대해서는 재전송 공격(replay attack)이 가능하다.

![alt](image/05%20CFB%20공격.jpg)

## 2.4 OFB(Output-FeedBack mode 출력 피드백 모드) 모드

OFB 모드에서는 암호 알고리즘의 출력을 암호 알고리즘의 입력으로 사용하는 방식이다. OFB 모드에서는 평문 블록은 암호 알고리즘에 의해 직접 암호화되고 있는 것은 아니다. 평문 블록과 암호 알고리즘의 출력을 XOR해서 암호문 블록을 만들어낸다.

![alt](image/05%20OFB%20암호화.png)

### 복호화

![alt](image/05%20OFB%20복호화.png)

## 2.5 CTR(CounTeR mode 카운터 모드) 모드

CTR 모드는 1씩 증가해 가는 카운터를 암호화해서 키 스트림을 만들어내는 스트림 암호 이다. CTR 모드는 블록을 암호화할 때 마다 1씩 증가시킨다. 즉, 카운터를 암호화 한 비트열과 평문 블록과의 XOR한 결과가 암호문 블록이 된다.

### 카운터 생성

카운터의 초기값은 암호화 할때마다 다른 값(nonce, 비표)을 기초로해서 만든다. 비표는 암호화시 매번 다른 값으로 지정한다. 예를 들어, 블록 길이가 128비트(=16바이트)인 경우 카운터의 초기값은 비표 '66 1F 98 CD 37 A3 8B 4B'와 블록 번호 '00 00 00 00 00 00 01'을 합쳐 카운터를 생성한다.

![alt](image/05%20CTR%20암호화.png)

### 복호화

![alt](image/05%20CTR%20복호화.png)

### OFB와 CTR 비교

![alt](image/05%20OFB와%20CTR%20비교.png)

### 특징

- CTR 모드의 암호화와 복호화는 완전히 같은 구조이므로, 프로그램으로 구현하는 것이 매우 간단하다.

- CTR 모드에서는 블록을 임의의 순서로 암호화・복호화할 수 있다.

    암호화・복호화시 사용하는 카운터는 비표와 블록 번호로부터 금방 구할수 있기 때문이다. **이는 OFB 모드에서는 없는 특징이다.**

### 오류와 기밀성

CTR 모드는 통신 오류와 기밀성에 관해서 OFB 모드와 거의 같은 성질을 가지고 있다.

- CTR 모드의 암호문 블록에서 1비트의 반전이 발생했을 경우 복호화를 수행하면, 반전된 비트에 대응하는 평문 블록의 1비트만이 반전되고, 오류는 확대대지 않는다.

- OFB 모드에서는 키 스트림의 1블록을 암호화한 결과가, 암호화 전 결과와 우연히 같아졌다고하면 그 이후 키 스트림은 완전히 같은 값의 반복이 된나 CTR 모드는 그렇지 않다.

## 2.5 모드 비교

|이름  |장점  |단점  |비고  |
|---------|---------|---------|---------|
|ECB     |-간단<br>-고속<br>-병렬처리(암호화, 복호화)         |-평문 속의 반복이 암호문에 반영된다.<br>-암호문 블록의 삭제나 교체에 의한 평문의 조작이 가능<br>-비트 단위의 에러가 있는 암호문을 복호화하면, 대응하는 블록이 에러가 된다.<br>-재생 공격이 가능         | 사용해서는안 된다        |
|CBC     |-평문의 반복은 암호문에 반영되지 않는다.<br>-병렬 처리(복호화)<br>-임의의 암호문 블록을 복호화할 수 있다.|-비트 단위의 에러가 있는 암호문을 복호화하면, 1블록 전체와 다음 블록의 대응하는 비트가 에러가 된다.<br>-암호화에서는 병렬 처리를 할 수 없다.         | 권장        |
|CFB     |  -패딩이 필요 없다.<br>-병렬 처리(복호화)<br>-임의의 암호문 블록을 복호화할 수 있다.| -암호화에서는 병렬 처리를 할 수 없다.<br>-비트 단위의 에러가 있는 암호문을 복호화하면, 1블록 전체와 다음 블록의 대응하는 비트가 에러가 된다.<br>-재생 공격이 가능|  -현재는 사용 안 함.<br>-CTR 모드를 사용하는 편이 나음      |
|OFB     |   -패딩이 필요 없다.<br>-암호화․복호화의 사전 준비를 할 수 있다.<br>-암호화와 복호화가 같은 구조를 하고 있다.<br>-비트 단위의 에러가 있는 암호문을 복호화하면, 평문의 대응하는 비트만 에러가 된다.|  -병렬 처리를 할 수 없다.<br>-능동적 공격자가 암호문 블록을 비트 반전시키면, 대응하는 평문 블록이 비트 반전한다     |  -CTR 모드를 사용하는 편이 나음.|
|CTR     |  - 패딩이 필요 없다.<br>- 암호화․복호화의 사전 준비를 할 수 있다.<br>- 암호화와 복호화가 같은 구조를 하고 있다.<br>- 비트 단위의 에러가 있는 암호문을 복호화하면, 평문의 대응하는 비트만 에러가 된다.<br>- 병렬 처리       |  -능동적 공격자가 암호문 블록을 비트 반전시키면, 대응하는 평문 블록이 비트 반전한다       |   권장      |

# 3. 스트림 암호

스트림 암호는 데이터 흐름인 스트림(stream)을 비트 단위로 순차적으로 처리해가는 암호 알고리즘으로서, one time pad를 실용적으로 구현할 목적을 개발되었다.

의사랜덤(pseudo random)키 생성기에 의해 생성된 키 스트림을 이용하며 키와 평문을 XOR하여 암호문을 생성합니다.

$$C_i = M_i \oplus StreamKey_i$$

## 3.1 스트림 암호 구조

## 3.2 스트림 암호 특징

- 키 스트림의 주기가 커야 한다.
- 키 스트림은 진성 랜덤 특성에 가능하면 근사해야 한다.
- 키의 길이는 충분히(128비트 이상)커야 한다.
- 잘 설계되었을 경우, 동일한 키 길이를 갖는 블록 암호 만큼의 보안성을 제공한다.
- 블록 암호에 비해 빠르고 단순하다.
- 키 재사용 시 암호 해독의 소지가 있다.

    같은 키를 사용한 두 암호문을 XOR하면 두 평문을 XOR한 결과와 같다. 블록 암호화는 그렇지 않다. 예를 들어, 평문 X와 Y가 있으며, 키 K를 이용하여 스트림 암호를 적용하여 나온 C와 D를 XOR하면 X와 Y를 XOR한 결과와 동일하다는 문제점이 있다.

    $X \oplus K = C and Y \oplus K = D, finally C \oplus D = X \oplus Y$

## 3.3 RC4

Ron Rivest가 설계한 스트림 암호이다. RSA사가 소유하고 있다. 다양한 키 길이를 지원하며 바이트 단위로 처리한다. 단순하면서도 효율적이여서 여러 표준에서 사용하고 있다.

> SSL/TLS, IEEE 802.11, WPA. Wi-Fi Protected Access 등에 사용하고 있다.

![alt](image/05%20RC4%20구조도.png)

위 그림은 RC4의 구조도이다. 키 스트림 K, 

### RC4 특징

- 알려진 공격에 대해 안전한다. 여러 논문에서 공겨 방버을 제안하였으나 사용하지 못했다.
- 스트림 암호 방법이기에 키의 재사용이 금지된다.
- WEP 프로토콜은 특정 공격에 취약하다.

    이는 RC4 자체의 결함에 의한 것이 아니라, 사용되어 지는 키의 생성에 의한 문제이다. 따라서 안전한 키를 생성하는 방법을 사용하면 해결될 수 있다.