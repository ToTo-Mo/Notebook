02 보안공격
===

# 1. DoS. Denial of Service 취약점 공격

## Boink, Bonk, TearDrop

TCP 프로토콜의 허점을 이용한 공격들이다. TCP 프로토콜에서는 신뢰성 있는 연결을 확인하기 위해 기본 기능을 제공합니다. TCP 프로토콜은 이러한 사항이 확인되지 않은 데이터 전송에 대해 신뢰도를 확보하기 위해 반복적인 재요청과 수정을 합니다. 

- 패킷의 순서가 올바른가?
- 중간에 손실된 패킷이 없는가?
- 손실된 패킷의 재전송 요청

Boink, Bonk, TearDrop은 이중에서 손실된 패킷의 재전송을 게속 요구함으로써 시스템 자원을 고갈 시키는 공격 방식입니다. TCP 패킷안에서 시퀸스 넘버를 속여 전송함으로써 재전송과 재조합에 과부하가 걸리도록 합니다.

## Bonk

Bonk는 처음 패킷을 1번으로 보낸후, 두번째, 세번째 패킷 모두 시퀸스 넘버를 1번으로 조작해서 보냅니다.

## Boink

Boink는 처음 패킷을 1번으로 보낸후 두번째 101번, 세번째 201번으로 정상적으로 보내다가 중간에 일정한 시퀸스 넘버로 보냅니다. 예를들어, 열번째 패킷은 1001번, 열한번째, 열두번째 패킷에도 1000번으로 보내는 것입니다.

## TearDrop

TearDrop은 UDP를 이용한 것이며, 앞의 Bonk와 Boink를 넘어서서, 일정 순서를 바꾸는것이 아니라 중첩과 빈공간을 만들며, 시퀸스 넘버를 좀더 복잡하게 섞는 역할을 합니다. 예를들어, 아래그림은 패킷 전송 순서에 따른 패킷의 시퀸스 넘버를 조작한 것입니다. 첫번째와 두번째 패킷 사이에 20만큼의 중첩이 생기고, 두번째와 세번째 사이에 40만큼의 공백이 생킨다. 그리고 세번째와 네번째 패킷 사이에서도 70 만큼의 중첩이 생긴다. 이처럼 전혀 맞지 않는 시퀸스 넘버 때문에, 패킷화된 데이터를 재조합 하는데, 혼란이 생겨 CPU에 과부하가 생기게되고, 시스템이 다운되게 된다.

| 패킷번호 | 정상패킷의 시퀸스 넘버 | TearDrop 시퀸스 넘버 |
| -------- | ---------------------- | -------------------- |
| 1        | 1 ~ 101                | 1 ~ 101              |
| 2        | 101 ~ 201              | 81 ~ 181             |
| 3        | 201 ~ 301              | 221 ~ 331            |
| 4        | 301 ~ 401              | 251 ~ 351            |

## Land 공격

패킷을 전송할 때 출발지 IP 주소와 목적지 IP 주소값을 똑같이 만들어서 공격 대상에게 보내는 공격이다. IP 주소는 공격 대상의 IP 주소로 한다.

Land 공격은 수신되는 패킷 중 출발지 IP와 목적지 IP주소가 동일한 패킷들을 차단함으로써 이 공격을 방지할 수 있다. 

# 2. Dos. Denial of Service 자원 고갈 공격형

## PoD. Ping of Death 공격

일반적으로 Ping 명령을 실행하면 ICMP Echo Request 패킷을 타켓 IP 주소로 송신하고 ICMP 응답을 대기합니다. 만약 방화벽이 ICMP 패킷을 차단하지 않는다면 공격 수단으로 이용될 수 있습니다.

IP 패킷의 최대 크기는 해더 20bytes를 포함하여 총 65535Bytes이다. Ping 명령을 보낼 때 패킷을 최대크기 이상으로 공격대상에게 보내면 타켓 호스트의 IP 스택을 넘치게하여 시스템 문제를 야기합니다.

> 윈도우8 부터는 일정 크기 이상의 Ping 패킷이 수신되면 자동으로 차단합니다.

> ICMP : TCP/IP에서 IP 패킷을 처리할 때 발생되는 문제를 알리거나, 진단 등과 같이 IP 계층에서 필요한 기타 기능들을 수행하기 위해 사용되는 프로토콜

## Ping Flood

Ping으로 발생되는 ICMP 메시지 응답을 기다리지 않고 반복적으로 공격 대상에게 전송하는 방식이다.

![alt](image/02%20Ping%20Flood.png)

## SYN Flooding. 

TCP의 취약점을 공격하는 기법이다. 네트워크에서는 서비스를 제공하는 시스템에는 동시 사용자 수에 대한 제한이 있다. SYN Flooding은 존재하지 않는 클라이언트가 서버 별로 한정되어 있는 접속 가능한 공간에 접속한 것처럼 속여 다른 사용자가 서버의 서비스를 제공하지 못하게하는 공격이다.

일반적으로 TCP 연결은 3way handshaking을 사용한다. 서버는 클라이언트가 ACK 패킷을 보내올 때 까지 SYN Received 상태로 일정 시간을 기다려야 하고, 그 동안 공격자는 가상의 클라이언트로 위조한 SYN 패킷을 수없이 만들어 서버에 보냄으로써 서버의 가용 동시 접속자 수를 모두 SYN Received 상태로 만든다. 

![alt](image/02%20TCP%203way%20handshaking.png)

![](image/02%20SYN%20Flooding.png)

### 대응

- Backlog Queue를 기본 128bit에서 확장한다.
- SYN Received의 대기 시간을 줄인다.
- 침임 방지 시스템(IPS)와 같은 보안 시스템을 통해 공격을 차단한다.

## HTTP GET Flooding 공격

대상 시스템에 TCP 3way handshaking을 통해 정상적인 접속을 한 뒤, 특정한 페이지를 HTTP의 GET method를 통해 무한대로 실행한다. 공격 패킷을 수신하는 웹 서버는 정상적인 TCP 세션과 함께 정상적으로 보이는 HTTP GET 요청을 지속적으로 요청하게 되므로 시스템에 과부하가 걸린다.

## HTTP CC. HTTP Cache-Control 공격

일반적으로 HTTP는 웹 트랜잭션의 효율화를 위해 Cache 기능을 사용합니다. 하지만, 자주 변형되는 데이터에 대해 새롭게 HTTP 요청 및 응답을 요구하기 위하여 Cache 기능을 off 할 수 있다. DoS 공격에서는 이를 응용하여 'Cache-Control: no-store, must-revalidate' 옵션을 사용하면 웹서버는 캐시를 사용하지 않고 응답해야 하므로 웹 서비스의 부하가 증가하게 된다.

- 동적 웹페이지 공격에 효과적이다.
- 웹 서버에 연관된 모든 요소의 부하를 증가시킨다.

## 동적 HTTP Request Flooding 공격

HTTP GET Flooding과 HTTP CC 공격은 지정된 웹 페이지를 지속적으로 요청하는 DoS 공격이다. 따라서 반복되는 HTTP 요청 패턴을 분석하면 방어가 가능하다. 반면에 동적 HTTP Request Flooding은 이러한 웹 방화벽을 통한 HTTP 요청 패턴 차단 기법을 우회하기 위해 지속적으로 요청 페이지를 변경하여 웹 페이지를 요청하는 기법이다.

## Smurf 공격

ICMP 패킷과 네트워크에 존재하는 임의의 시스템들을 이용하여 패킷을 확장시켜서 서비스 거부 공격을 수행하는 방법이다. 네트워크를 공격할 때 많이 사용한다. 아래 그림은 브로드캐스팅에 대한 그림이다. 일반적으로 서브넷 마스크가 255.255.255.255이면 연결된 로컬 호스트들에게 데이터를 전송한다. 여기서 서브넷 마스크가 10.255.255.255이라면 라우터가 로컬 네트워크에 있는 모든 호스트에게 데이터를 전송합니다. Smurf는 이점을 노린 공격방식이다.

![alt](image/02%20Smurf1.png)
![alt](image/02%20Smurf2.png)

## Mail Bomb 공격

Mail Server는 사용자에게 일정양의 저장 공간을 할당하는데, 메일이 폭주하면 저장 공간의 부족으로 정상적인 메일의 수신이 어려워진다. 즉, 스팸 메일도 DoS 공격의 일종이다.

## DDos. Distributed Denial of Service 공격

피해가 상당히 심각하며 이에 대한 확실한 대책 역시 없고 공격자의 위치와 구체적인 발원지를 파악하는 것도 거의 불가능에 가까다.

특성상 대부분의 공격이 자동화된 툴을 이용. 

공격의 범위가 방대하며 DDoS 공격을 하려면 최종 공격 대상 이외에도 공격을 증폭시켜주는 중간자가 필요하다. 

### Dos 공격 구성

- 공격자(Attacker) : 해커의 컴퓨터
- 마스터(Master) : 공격자에게 직접 명령을 받는 시스템
- 핸들러(Handler) 프로그램 : 마스터 시스템의 역할을 수행하는 프로그램
- 에이전트(Agent) : 공격 대상에 직접 공격을 가하는 시스템
- 데몬(Daemon) 프로그램 : 에이전트 시스템의 역할을 수행하는 프로그램

최근 DDoS 공격은 악성코드(Bot)와 결합하는 형태이다. PC에서 전파가 가능한 형태의 악성코드를 작성한다. DDoS에 의해 사전에 공격 대상과 스케줄을 정한 뒤 이를 작성한 악성코드에 코딩하고 인터넷으로 전파합니다. 전파과정중 Bot은 잠복해 있으며, Bot에 감염된 PC를 좀비 PC, 좀비 PC끼리 연결된 네트워크를 Botnet이라 한다.

공격자가 명령을 내리거나 정해진 스케줄에 따라 botnet으로 형성된 좀비 PC들이 일제히 공격을 한다.

# 2. Sniffing

네트워크를 통해 전송되는 데이터를 불법으로 도청한다. 스니핑 공격의 종류는 다음과 같다.

- 전화선이나 UTP에 Tapping을 해서 전기적 신호를 분석해 정보를 찾아내는 것
- 스위치 재밍(MACOF)
- ICMP 리다이렉트

정상적인 네트워크에 접속하는 모든 시스템은 설정된 IP 주소값과 고유한 MAC 주소값을 가지고 있다. 네트워크 카드는 MAC 정보와 IP 주소를 가지고 자신의 랜 카드에 들어오는 프로토콜 형식에 따른 전기적 신호의 헤더 부분, 즉 주소값을 인식하고 자신의 버퍼에 저장할지를 결정한다.
네트워크 카드에 인식된 2계층과 3계층 정보가 자신의 것과 일치하지 않는 패킷은 무시한다.

![alt](image/02%20네트워크%20필터링.png)

## Promicuous Mode

Promicuous Mode는 스니핑을 수행하는 공격자가 2계층과 3계층에 대한 필터링 기능을 해제한다. 

![alt](image/02%20Sniffing%20Promicuous%20Mode.png)

## 스위치 재밍

스위치는 실제 수신 대상으로만 패킷을 보내는 브릿지(2계층) 장비이다. 스위치는 저장된 주소 테이블을 보고 수신 대상을 지정한다. 스위치 재밍은 스위치의 주소 테이블의 기능을 마비시키는 공격이다. 많은 종류의 스위치는 주소 테이블이 넘치면 패킷을 모든 포트로 브로드캐스팅 하는 성질이 있다. 

엉뚱한 MAC 주소를 가진 패킷을 게속 보내 스위치의 버퍼를 채우게 된다. 이는 스위치를 더미허브로 처럼 동작시키게 된다. 

## ICMP 리다이렉트

보통의 네트워크는 라우터나 게이트웨이가 하나있습니다. 하나의 라우터로 네트워크 트래픽을  감당할 수 없을 때 라우터나 게이트웨이를 두 개 이상 운영해서 로드밸런싱(Load balancing)을 유지합니다. 시스템의 라우팅 테이블에 라우팅 엔트리를 하나 더 넣어주는 방법도 있으나 ICMP 리다이렉트를 사용하기도 합니다.

ICMP 리다이렉트 공격은 이러한 ICMP 리다이렉트를 악의적으로 사용한 네트워크에 여러 개의 라우터가 있는 경우, 좀 더 효율적 경로라고 판단되는 특정 라우터의 IP 주소를 ICMP 리다이렉트 메시지를 통해 보낼 수 있습니다.

ICMP 리다이렉트 받은  PC는 패킷의 내용대로 라우팅 테이블을 변경하는데, 인증 메커니즘이 없기 때문에 스니핑 공격의 방법으로 사용될 수 있음

### 동작 순서

1. 호스트 A가 원격의 호스트 B로 데이터를 보낼 때 라우터 A가 디폴트(Default) 라우터로 설정되어 있기 때문에 호스트 A는 원격으로 보내는 모든 패킷을 라우터 A로 보낸다. 
1. 라우터 A는 호스트 B로 보내는 패킷을 수신하고 라우팅 테이블을 검색하여 라우터 B가 호스트 B에 도달하는데, 좀더 효율적이라 호스트 A가 보낸 패킷을 라우터 B로 보낸다.
1. 라우터 A는 다시 호스트 A가 호스트 B로 향하는 패킷을 자신에게 전달하지 않도록 호스트 A에게 ICMP 리다이렉트 패킷을 보내 호스트 A가 호스트 B로 보내는 패킷이 라우터 B로 바로 향하도록 한다
1. 호스트 A는 라우팅 테이블에 호스트 B에 대한 값을 추가하고, 호스트 B로 보내는 패킷은 라우터 B로 전달한다.

![alt](image/02%20Sniffing%20ICMP%20Redirect.png)

이를 이용하면 공격자는 공격 대상에게 패킷을 자신에게 전달하도록 ICP 메시지로 만들어 전송합니다.

![alt](image/02%20Sniffing%20ICMP%20Redirect%20Attack.png)

# 3. Spoofing

Spooing은 사전적 의미로 '속이다'이다. Spooing은 속임을 이용한 공격을 총칭하는 용어이다. 네트워크에서 Spooing 대상은 MAC주소, IP주소, 포트등 네트워크 통신과 관련된 모든 것이 될 수 있다.

## ARP Spoofing

ARP Spoofing은 MAC 주소를 속이는 방식이다. 

![alt](image/02%20ARP%20Spoofing.png) 

![alt](image/02%20ARP%20Spoofing2.png)

### 대응책

- ARP 테이블이 변경되지 않도록 MAC 주소를 고정시킨다.
- 클라이언트의 ARP 테이블의 내용이 바뀌면 경고 메시지를 보내는 보안 툴을 사용한다.

## IP Spoofing

트러스트를 이용한 접속은 네트워크에 패스워드를 뿌리지 않기 때문에 스니핑 공격에 안전한것으로 보인다. 하지만 인증이 IP를 통해 일어나므로, 공격자가 해당 IP를 사용해서 접속하면 패스워드가 필요없다.

1. 클라이언트에 Dos 공격을 가해 클라이언트의 연결을 차단한다.
2. 서버에 특정 IP로 접속한다.

> 트러스트 : 파티에 초대한 사람 중 친분이 있는 사람은 초대장을 확인하지 않고 그냥 들여보내주는 것

## ICMP Redirect

1. 공격자가 라우터 B가 되어 ICMP 리다이렉트 패킷을 공격 대상에게 전송
2. Target은 데이터 패킷를 Attacker에게 전송
3. Attacker는 다시 패킷를 라우터 A로 릴레이

## DNS Spoofing

정상적인 DNS에서는 클라이언트가 DNS 서버에게 접속하고자 하는 IP 주소를 질의한다. DNS 서버가 해당 도메인 이름에 대한 IP주소를 클라이언트에게 보내주고 클라이언트가 받은 IP 주소를 바탕으로 웹 서버를 찾아간다.

DNS Spoofing은 실제 DNS 서버보다 빨리 공격 대상에게 DNS Response 패킷을 보내, 공격 대상이 잘못된 IP 주소로 웹 접속을 하도록 유도하는 공격이다.

1. Target이 DNS Query 패킷을 보내는 것을 확인. 

    - (Hub 환경) 모든 패킷이 자신에게도 전달되므로 Target이 DNS Query 패킷을 보내는 것을 자연스럽게 확인
    - (Switching 환경) Target이 DNS Query 패킷을 보내면 이를 받아야 하므로 ARP 스푸핑과 같은 선행 작업이 필요함. 

2. 공격자는 로컬에 존재하므로 DNS 서버보다 지리적으로 가까움. 

    - DNS 서버가 올바른 DNS Response 패킷을 보내주기 전에, Target에게 위조된 DNS Response 패킷을 전송

3. Target은 공격자가 보낸 DNS Response 패킷을 올바른 패킷으로 인식하고, 웹에 접속. 이때, 지리적으로 멀리 떨어져 있는 DNS 서버가 보낸 DNS Response 패킷은 버림.

    - hosts 파일에는 URL과 IP 정보가 등록되어 있음.

# 4. Session Hijacking

Session은 사용자와 컴퓨터, 또는 두 대의 컴퓨터 간의 호라성화 상태를 의미한다. Session Hijacking은 두 시스템 간 연결이 활서화된 상태, 즉 로그인된 상태를 가로채는 것을 의미한다. 

## TCP Session Hijacking

TCP가 가지는 고유한 취약점을 이용해 정상적인 접속을 빼앗는 방법이다. TCP는 서버 클라이언트 간 통신을 할 때 패킷의 연속성을 보장하기 위해 클라이언트와 서버는 각각 시퀸스 넘버를 사용한다. 시퀸스 넘버의 오류 시, 이를 바로 잡기 위한 작업을 하는데, TCP 세션 하이캐징은 서버와 클라이언트에 각각 잘못된 시퀸스 넘버를 위조해서 연결된 세션에 잠시 혼란을 준 뒤 자신이 끼어들어가는 방식이다.

### 순서

사전에 C-S 사이의 패킷을 통제 (ARP 스푸핑 등을 통해 C-S 사이의 통신 패킷이 모두 공격자를 지나가게 함)

1. 클라이언트는 서버와 모두 접속되어 있는 Established 상태이며, 공격자는 적절한 시퀀스 넘버를 획득하기 위해 스니핑 중
1. 공격자는 세션이 완전히 끊어지지 않는 시퀀스 넘버의 범위에서 RST 패킷을 생성하여 서버에 보냄. 서버는 잠시 Closed 상태가 되나 클라이언트는 그대로 Established 상태
1. 공격자는A_Client_My_Seq 를 생성하여 서버에 보냄서버는 새로운 A_Client_My_Seq 를 받아들이고, Server_My_Seq 를 재생성하여 공격자에게 보낸 후 Syn_Received 상태가 됨
1. 공격자는 정상 연결처럼 서버와 시퀀스 넘버를 교환하고, 공격자와 서버 모두 Established 상태가 됨. 원래의 클라이언트는 여전히 Established 상태고 서버의 네트워크 상태로 인한 잠시 동안의 연결 문제로 받아들이며, 연결은 끊어졌지만 인증 세션은 열린 상태임
1. 공격자는 공격 전 클라이언트가 서버와 통신을 하던 시퀀스 넘버를 모두 알고 있는 상태이므로 클라이언트와 정상적인 통신을 하며, 서버와는 공격자가 새로 생성한 시퀀스 넘버를 가지고 통신
